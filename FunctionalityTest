package Breakpoint;

import java.awt.Color;

import acm.graphics.GLabel;
import acm.graphics.GObject;
import acm.graphics.GPoint;
import acm.program.GraphicsProgram;

public class FunctionalityTest extends GraphicsProgram{

//	private static final double SIZE = 5;
//	AnimatedBall redBall = new AnimatedBall(SIZE);

	public void run() {
		
		setSize(Model.getWidth(), Model.getHeight());
		
		AnimatedBall curBall = Model.getRedBall(); 
		
		curBall.setFilled(true);
		curBall.setColor(Color.RED);
		add(curBall, Model.getBallStart());
		
		GLabel startMessage = new GLabel("Click to start Breakout!");
		startMessage.setLocation(Model.getPaddleStart().getX() - 50, Model.getPaddleStart().getY() + 25);
		add(startMessage);
		
		Thread redBallThread = new Thread(curBall);
			
		waitForClick();
		remove(startMessage);
		redBallThread.start();
		
		while(redBallThread.isAlive() && !Model.isLost() && !Model.isWon()){
			println(curBall.getLocation().toString());
			
			
			if(wouldCollide(curBall)){
				//curBall.setDirection(calculateDirection(curBall,getElementAt(curBall.getX(),curBall.getY())));
			}

		}
	}

private boolean wouldCollide(AnimatedBall curBall) {
	
	double deltaX = Math.sin(curBall.getDirection());
	double deltaY = Math.cos(curBall.getDirection());
	double redX = curBall.getX();
	double redY = curBall.getY();
	double delta = AnimatedBall.getDelta();
	double size = AnimatedBall.getBallSize();
	return	getElementAt(redX + deltaX * delta , redY + deltaY * delta) != null ||
			getElementAt(redX + deltaX * delta + size , redY + deltaY * delta) != null ||
			getElementAt(redX + deltaX * delta , redY + deltaY * delta + size) != null ||
			getElementAt(redX + deltaX * delta + size, redY + deltaY * delta + size) != null;
}
		
//	private double calculateDirection(AnimatedBall redBall, GObject elementAt) {
//		double newDirection;
//		if(elementAt instanceof Brick /*|| elementAt instanceof Wall*/){
//			newDirection = reflect(redBall, elementAt);
//		}else if(elementAt instanceof Paddle){
//			newDirection = paddleReflect(redBall, elementAt);
//		}else if(elementAt instanceof Bottom){
//			
//		}
//	
//		return newDirection;
//	}

//	private double paddleReflect(AnimatedBall redBall, GObject elementAt) {
//		double newDirection;
//		// TODO Implement correct paddleReflection
//		double direction = redBall.getDirection();
//		newDirection = direction + 180;
//		
//		return newDirection;
//	}
//
//	private double reflect(AnimatedBall redBall, GObject elementAt) {
//		double newDirection;
//		double direction = redBall.getDirection();
//		int side = (int) (direction / 180);
//		switch (side) {
//		case 0:
//			newDirection = 180 - direction;
//		case 1:
//			newDirection = 360 - direction;
//		default:
//			assert (false): "Reflection can not be callucalted correctly";
//			newDirection = direction;
//		}
//		return newDirection;
//	}	
	
}
